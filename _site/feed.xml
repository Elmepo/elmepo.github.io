<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-AU"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-AU" /><updated>2025-05-29T16:27:53+10:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Scott Gardner</title><entry><title type="html">So when is scrum good?</title><link href="http://localhost:4000/blog/when-is-scrum-good" rel="alternate" type="text/html" title="So when is scrum good?" /><published>2025-05-28T00:00:00+10:00</published><updated>2025-05-28T00:00:00+10:00</updated><id>http://localhost:4000/blog/when-is-scrum-good</id><content type="html" xml:base="http://localhost:4000/blog/when-is-scrum-good"><![CDATA[<h1 id="so-when-is-scrum-good">So when is scrum good?</h1>

<p>Never let it be said that I’m ideological. <a href="/blog/you-dont-need-scrum">Look, I don’t like Scrum</a> - I think it’s largely an artefact of a time from before I was even born. But I also think it was a required step in the journey from where software started off, with rigidly defined steps and roles, to a brighter future. It’s certainly not the worst possible way to organise software delivery teams and has it’s benefits. We have to understand these benefits, because otherwise we risk recreating scrum in the aggregate, with none of the benefits and all of it’s flaws because we collectively fail to grasp why scrum works and why it fails.</p>

<h2 id="1-scrum-lifts-up-bad-developers">1. Scrum lifts up bad developers.</h2>
<p>If you work in the software industry long enough, you’ll eventually meet some truly bad developers. Sometimes they’re simply junior developers. People still learning the ropes and with either no prior context or who’ve never been taught how to do things and why. Other times, they’re people who make you wonder how they snuck past the interview process and how they’re allowed to stay.</p>

<p>Developers who spend months working on a feature without even checking to see if it fixes the problem they’re trying to solve. Developers who continually run into the same issues, or who refuse to take any ownership of their code once it’s been committed. Hell I once worked with someone who wrote tests for their code, but then updated the deployment logic to just ignore any test failures.</p>

<p>Scrums approach, focusing on short to medium length feedback loops consisting of: Deciding what you want to achieve over the next x days, Trying to do that, Thinking about what went wrong and what went right - <strong>will</strong> take any particularly bad developer and forcefully pull them up to a relatively low baseline standard.</p>

<h2 id="2-scrum-protects-development-teams-from-stakeholders">2. Scrum protects development teams from stakeholders</h2>
<p>Along the same lines, scrum protects development teams from undue outside influence. It makes it more difficult for product or sales people to try and force a team to drop what they’re doing and focus on their request. It makes those same people an active participant in the development process, asking them to review the work that’s going on and avoid painful mistakes where a team spends months on a feature only to discover at the last minute it’s the complete opposite of what was requested.</p>

<p>In the best case scenarios, teams are able to use the sprint based nature of scrum to spend time proactively paying technical debt and incorporate more robust technical requirements into their development cycle to avoid increasing their technical debt, something that is difficult (particularly in more toxic companies) when not using sprints. Scrum’s rigid processes act as a kind of bulwhark against these kinds of issues, even if it still doesn’t completely stop them. In low performing teams and toxic companies, being able to provide any kind of support for good development practices is too good of an opportunity to pass up.</p>

<h2 id="3-scrum-usually-forces-developers-to-avoid-silos">3. Scrum (usually) forces developers to avoid silos</h2>
<p>Whilst not <em>strictly</em> scrum, I think it’s fair to say that 99 percent of scrum teams consist of multiple developers across different functions. This is without a doubt a massive benefit. By forcing developers from different functions to consistently interact with people from other functions, you avoid a whole host of problems. Your backend developer is aware of how the frontend will consume their api. QA is aware of how exactly the backend is processing data, so they can ensure all bases are covered by their tests.</p>

<p>In a perfect world, this will also result in a cross pollination effect, where each developer can start to pick up skills and approaches from other functions. You might not end up with a team of fullstack engineers proficient in every language and framework under the sun, but at least they’ll start to have an appreciation for the limitations and strengths of the tools used by everyone in the team.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[So when is scrum good?]]></summary></entry><entry><title type="html">What’s left to do</title><link href="http://localhost:4000/blog/todo" rel="alternate" type="text/html" title="What’s left to do" /><published>2025-05-27T00:00:00+10:00</published><updated>2025-05-27T00:00:00+10:00</updated><id>http://localhost:4000/blog/todo</id><content type="html" xml:base="http://localhost:4000/blog/todo"><![CDATA[<h1 id="todo">Todo</h1>

<ul class="task-list">
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Add a picture to the about page</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Take pictures for the projects page
    <ul class="task-list">
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Text Editor</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Blog</li>
    </ul>
  </li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Get text editor to v1</li>
  <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />Deploy Cafeok project to the public</li>
</ul>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[Todo]]></summary></entry><entry><title type="html">You don’t need scrum</title><link href="http://localhost:4000/blog/you-dont-need-scrum" rel="alternate" type="text/html" title="You don’t need scrum" /><published>2025-05-26T00:00:00+10:00</published><updated>2025-05-26T00:00:00+10:00</updated><id>http://localhost:4000/blog/you-dont-need-scrum</id><content type="html" xml:base="http://localhost:4000/blog/you-dont-need-scrum"><![CDATA[<h1 id="blog-header">You don’t need scrum</h1>

<p>Something I’ve never really been able to mesh with a lot of people in my industry is that I just don’t get Scrum. It’s existence stands out as a weird anomaly in a field full of anomalies. As a part of our industry, in my opinion it’s the only standard that exists because we collectively have decided that against all evidence otherwise, it works.</p>

<p>Scrum is one of those strange things where you can find plenty of people talking about how nice it is. Lots of conferences about it and youtube videos waxing eloquent not just about it, but about hyper specific implementations and nuances <em>about</em> it. Strangely enough, however, no one’s ever bothered to ask if it actually works. It feels as though everyone just woke up one day and decided that this was it. People are quick to attach things to Scrum, but never really seem to be able to prove it’s benefits on it’s own merits. Much like the “Spotify Model”, something that Spotify used for about just long enough to create a god awful video talking about how great it was, before dropping it like a pile of hot rocks.</p>

<p>If you read anything about scrum, scrum proponents are almost constantly, whether on purpose of not, using complex linguistic tricks to pretend that anything good that has ever happened in software was because of scrum.</p>

<p>Agile is good, and Scrum says it’s agile, ergo scrum is good. Lots of high performance teams use standups, and scrum uses standups, ergo high performance teams use scrum. On and on and on, it seems like despite very few high performance teams seeming to even acknowledge scrum exists - let alone going to scrum conferences or talking about scrum or singing it’s praises to anyone who’ll listen.</p>

<p>So then why does basically everyone use scrum? I mean, besides inept technical leadership, because really scrum can’t be blamed for that. That’s unfortunately a much bigger and much more common problem. I’ve always been perplexed at how scrum can so constantly be a part of discussions around “high performing teams” when the actually high performing teams at places like Google, Facebook, and Netflix, don’t use scrum at all.</p>

<p>That’s not to say that I don’t believe there’s a few things that Scrum does have going for it. The great benefit of scrum I think, is that it is the great equaliser. Executed correctly, it can take any team of developers and make them all slightly worse than average. Maybe even average if you’re lucky. Forcing developers to actually think about the work they’re doing, making them think about what their next week or two is going to look like and how they can actually achieve something in that time, and then looking back on what they’ve done, can be pretty powerful.</p>

<h3 id="if-youre-working-with-low-performers"><strong>If you’re working with low performers</strong></h3>

<p>I mean, basically. Scrum’s whole deal is really great for taking people who are bad at their jobs - juniors or otherwise really poor engineers - and turning them into people who could meet basic bare minimums. It seems like whenever I see scrum success stories (where that success could actually be attributed to scrum), the common thread seems to be that the teams just weren’t that good in the first place. Which, sure, scrum will help with that. But honestly is that what you want? A team of people who have to be forced via strict processes to take a very basic level of ownership and responsibility over their work?</p>

<p>And what’s the cost of all of this? <strong>It’s that any developer that’s more than “just okay”, will also inevitably fall to that level.</strong> The key to good development work is fundamentally uninterrupted time to focus on the problem at hand. As Paul Graham once wrote: <a href="https://paulgraham.com/makersschedule.html">“[Programmers] generally prefer to use time in units of half a day at least”</a>. Scrum of course, instead takes the approach that if a developer is having difficulty solving a problem, then surely the problem is that they haven’t had <em>enough</em> meetings. The problem just isn’t defined well enough, so maybe a refinement session will help. Then after that refinement session maybe they could have a three amigos meeting to really clarify the problem. Of course they’ll still have the daily standup to go to, along with a review session.</p>

<p>It never ceases to amaze me that whenever I see scrum proponents talking about these very specific concerns from developers, they seem to be completely unable to conceptualise that their very solution is the problem. For any good developer, basically the only justifiable meeting is the daily standup and that’s about it. Virtually every other meeting is something that at best is net neutral and in most cases something that actively hurts what they’re trying to achieve.</p>

<h3 id="your-stakeholders-can-be-low-performers-too">Your stakeholders can be low performers too</h3>

<p>The one other thing that scrum has going for it is that the scheduled nature works really well with non technical stakeholders. When people can’t understand exactly why estimating technical tasks can be so inaccurate, forcing them into the same schedule the developers are using can have some really strong benefits. It doesn’t necessarily make the relationship perfect - everyone has worked on a project where the stakeholders changed everything mid sprint and then complained when goals weren’t met - but it does <em>improve</em> it.</p>

<p>There is, unfortunately a double edged sword in this faustian bargain. Inevitably when work is expressed in strict units of time, people begin to play politics with it. Technical debt almost always takes a backseat to feature work, often placed into the catchall bucket called “if we have time this sprint”. It’s also hard to argue with stakeholders why they should wait at least another two weeks for the feature they think will increase revenue by 10% while the team works on some complex technical issue that they can’t explain and has no direct monetary benefits. I think it’s no surprise that the single most common approach recommended to paying down any technical debt is to simply lie about how long something will actually take and then use that buffer to patch the holes.</p>

<p>This isn’t to say that without scrum stakeholders become technologists, approving any and all technical debt work developers request. But I think that there’s something to be said about the nature of longer timelines causing a lower tolerance to delays, particularly how it relates to viewing timing as a budget that should be spent. In my experience, leaving technical debt to “if we have time” results in solutions that are much worse and representative of the time available for the solution. If a team closes out all of it’s work a day earlier, yes, they <em>(may)</em> have a day now to work on technical debt. But rather than create a solution that solves the problem long term, developers are incentivised to instead create a solution <em>within that day</em>. In almost all cases, this merely kicks the can down the road, creating more technical debt that developers simply hope they’ll be able to justify spending a proper amount of time on in six months time.</p>

<h3 id="so-whats-the-solution-then">So what’s the solution then?</h3>

<p>In short - Hire better engineers.</p>

<p>Look it’s 2025. It’s not the 90s anymore when something like scrum was revolutionary. The idea of a developer saying they “just write code” and don’t need to think about what that code is actually doing for stakeholders, whether that’s generating new revenue or saving costs, is becoming exceedingly rare. Developers are taking more responsibility for what we write and most people will need to have an appreciation for the context even if they don’t think they have to. A developer is no longer just a developer but someone who has at least surface level knowledge of topics like QA and infrastructure. They don’t need to be reminded every two weeks that they’re updating a function because it’s not performant and smashing the database. Hell chances are that they’re the ones who pushed to change the function because they’re tired of being woken up at 3am when a random spike in traffic causes the database to keel over one too many times.</p>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[You don’t need scrum]]></summary></entry><entry><title type="html">You’re probably thinking about automation the wrong way</title><link href="http://localhost:4000/blog/thinking-about-automation-wrong" rel="alternate" type="text/html" title="You’re probably thinking about automation the wrong way" /><published>2025-05-23T00:00:00+10:00</published><updated>2025-05-23T00:00:00+10:00</updated><id>http://localhost:4000/blog/thinking-about-automation-wrong</id><content type="html" xml:base="http://localhost:4000/blog/thinking-about-automation-wrong"><![CDATA[<h1 id="youre-probably-thinking-about-automation-the-wrong-way">You’re probably thinking about automation the wrong way</h1>
<!-- {: #blog-header} -->

<p>In infrastructure there’s a term that gets thrown around a lot among SREs and Platform Engineers, “Sysadmin who codes”. As DevOps began gaining more popularity and roles began to change, with roles like Site Reliability Engineer, Platform Engineer, and DevOps Engineer<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>, People who had previously worked as Systems Administrators, rarely if ever writing any code, were suddenly required to become programmers. Often used in a somewhat derogatory way, it’s presence is a strong indicator of how the DevOps community views ourselves and our roles - where we are and where we’ve come from.</p>

<p>The difference between an SRE and a “Sysadmin who codes” might not immediately be obvious, particularly to anyone not in our industry. After all, isn’t that what Site Reliability Engineering is all about? Isn’t that just what Google did? Hired Sysadmins who could code? Why would that be a bad thing? It’s easy to see how the narrative was formed, but the reality is that Google never did that. Instead, Google did the opposite. They hired Software Engineers and set them to working on their infrastructure. This (to some subtle) difference is responsible for arguably the biggest scism in our industry.</p>

<p>So what’s the difference? In short, it’s the approach and mindset, and to a smaller extent the skills and capabilities. “Sysadmins who code” often have a more process orientated mindset and a view to resolving problems using less abstract ways. Typically while they have the ability to write code, they lack any training and may find themselves unable to understand relatively basic algorithms and why they’re used. In my experience, the code I’ve seen from these kinds of engineers is functional, but not particularly maintainable.</p>

<p>The biggest way I’ve noticed this manifesting is the way in which people approach resolving problems via “automation”. To me it’s one of the biggest indicators of someone’s mindset and potential red flags to look out for when interviewing or talking to people. A “Sysadmin who codes” views a script as an automated replacement for themselves - a digital record of the actions they would take with little to no internal logic or problem solving. Most engineers I know, understand that the actions a person needs to take to perform a task isn’t always the actions that a computer should take.</p>

<p>Often, this also relates to how the program is run and where responsibility for any impacts lies. Most sysadmins I’ve seen take a certain view that programs shouldn’t make “serious” decisions, instead requiring user input or confirmation for those steps. On some level, this can be unavoidable - sometimes things are just too dangerous to avoid at least a confirmation. In my experience though, this is usually a sign that a process is broken somewhere, and that’s what should be focused on instead. In my opinion, good engineers understand that responsibility for a programs lie with the program itself, not on the user or process running the program. If I give you a program to reset the data in a test database, if it accidentally overwrites the production database, we shouldn’t blame the user but rather the system that allowed the mistake in the first place.</p>

<p>This will usually also be seen in a reverence for runbooks and documentation. Not that I have any issues with either - they’re incredibly important components of any system, but not everything needs to be documented and realistically everytime a runbook is written, you should be asking youself if that’s the best solution. This is where the sysadmins who code often have the biggest trouble in my experience. Historically that was the best way to solve problems as a sysadmin - write down exactly what you did to resolve an issue - after all maybe it’ll happen again next year long after you’re gone and no one else knows exactly what you did or even why. With computers though? They never forget and they never make mistakes or change how they do things, even when you want them to. In my view, self-healing script triggered by an alert &gt; Runbook explaining which script or pipeline to run &gt; Runbook explaining what commands to run.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></p>

<p>All of this isn’t to say that there’s no space left for Systems Administrators in our industry, or even that a team solely of “Sysadmins who code” is a red flag in of itself. With these kinds of things I think it’s always important to remember the context that people are in - how big is the company and how complex is their infrastructure? How important is software to the business’s profit margins? You don’t need to be writing complex programs for a local accountancy. It is, however, important to watch out for when you <strong>do</strong> need to be tackling these complex problems.</p>

<p>If you’re working in an environment that requires self healing infrastructure, that requires <a href="uptime.is/three-nines">3 or more 9’s of uptime</a>, it’s more or less impossible to get there with people who have this kind of mindset. Complex, highly available environments require automated processes that are capable for thinking and reasoning for themselves<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote" rel="footnote">3</a></sup>. After all, if you have an SLA with no longer than 30 minutes downtime per month, you’re probably losing half of that time just in your oncall engineer responding to the alert. Add on that you’re almost certainly not alerting issues immediately but on some kind of timeseries based metric, and it’s not unimaginable that by the time the problem has occurred, alerted (and woken up) your oncall engineer, they’ve drearily booted up their laptop, looked at the issue and determined the script to run to fix the issue, you’ve already blown past not just this months SLA, but possibly next months as well. You need something that is a) never asleep and b) capable of immediately taking action.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Generally speaking I hate the term “DevOps Engineer” and consider it to be the same as “Scrum Master” - examples of roles that should never have existed and go against their very origins, but that’s a topic for another day. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>It’s always worth remembering that while it’s unlikely your cloud CI server will be down, it can happen and so the best self-healing system is either self-healing itself or simply calls a script that your oncall engineer <em>could</em> run themselves if the CI server did die. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Within reason <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="blog" /><summary type="html"><![CDATA[You’re probably thinking about automation the wrong way]]></summary></entry><entry><title type="html">Becoming a manager</title><link href="http://localhost:4000/blog/becoming_a_manager" rel="alternate" type="text/html" title="Becoming a manager" /><published>2025-05-22T00:00:00+10:00</published><updated>2025-05-22T00:00:00+10:00</updated><id>http://localhost:4000/blog/becoming_a_manager</id><content type="html" xml:base="http://localhost:4000/blog/becoming_a_manager"><![CDATA[<h1 id="thoughts-after-1-year-of-management">Thoughts after 1 year of management</h1>

<p>I’ve officially been a team lead, managing up to 4 people, for one year. Like many people, I had held unofficial leadership positions before, but the last 12 months marked the first time that was official, with all the ups and downs that come with it. It’s been an interesting journey - and I’ve learned some incredibly important, interesting, and often conflicting things about management.</p>

<p>The first thing that I had to come to terms with was just how different the job was. I was promoted internally to lead the very same team I had previously been part of, and so I assumed that there wouldn’t be that much difference. Sure I’d be in a few more meetings, I’d have to write the occasional report and deal with the odd interpersonal problem, but it’s not like much would change, right?</p>

<p>I couldn’t have been more wrong. For one thing, it wasn’t just “a few more meetings”. My calendar might have been free, but barely a day went by that I didn’t have multiple long conversations about some issue that needed to be raised or resolved, from both inside and outside my team. Along with necessary admin work and other duties, as a programmer I really started to understand PG’s Manager Time/Maker Time essay. My technical work quality was immediately directly tied to how much time I had that day.</p>

<p>This started to become a problem because as a Team Lead, I was still expected to perform technical tasks. I quickly found myself struggling to keep up with technical details and specifics, and would often find myself having to backtrack on something I said or committed to. I would eventually read that Google considers the Team Lead position to be one of the most stressful and complex positions for this exact reason - you need to be capable of performing both management and technical tasks just as good as somebody specialising in either, with half the time.</p>

<p>I was also surprised to learn just how much of the job was political. As a manager you’re more privy to the goings on in the company, and you find yourself thinking on a different level than you may have ever done as an individual contributor. You see the reasons why an underperforming team is still being kept around or why certain product lines are being explored, and you also start to understand exactly where you and your team sit in the value stream and (hopefully) the value they bring to your company.</p>

<p>This becomes a background process constantly running in your head. Suddenly, decisions aren’t necessarily so clear. You’re weighing up not just what the team wants to do and what they think is important, but how that will affect the team and the rest of the organisation. Spending time rewriting a service in a new language might help your team in the future, but another team relies on it and needs changes made yesterday or they might miss quarterly goals.</p>

<p>The words you use also suddenly become much more important. You’re hiring for a position and people are suggesting reaching out to a former colleague you know won’t be rehired. Do you avoid the topic or say something non-committal? People are complaining about how infrequently someone is in the office, do you reveal they’re going through an intense personal issue right now, or do you say nothing and potentially impact that person’s workplace relationships? When you’re talking to non-technical people, how do you communicate complex technical topics and problems and how they relate to the changing dates you’ve committed to?</p>

<p>There’s rarely any right answers in the role and you’re usually trying to find the right balance between multiple less than ideal scenarios. These issues are also very rarely visible on any kind of fair timeframe. You won’t know if you made the right decision until weeks, months, or potentially even years later. Coming from a programming background where getting fast feedback loops was considered baseline requirements, and changes that took longer than a few minutes to verify considered “slow”, this was easily the hardest aspect of management for me to come to terms with.</p>

<p>Gradually, however, you get better at it. In the same way a junior engineer doesn’t understand basic sorting functions at first and slowly over time learns the logic and reasoning behind them, you start to understand what you need to do, and decisions come to you more naturally. Sometimes, this is because you’ve been bitten before or you’ve been warned it could come up. Other times you just get a feeling in your stomach telling you which direction to take or what words to use even if you don’t really know <em>why</em> you think so. Eventually, things that were incredibly alien at first become more natural and effortless.</p>]]></content><author><name></name></author><category term="blog" /><category term="management" /><summary type="html"><![CDATA[Thoughts after 1 year of management]]></summary></entry></feed>